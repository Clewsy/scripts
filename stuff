#!/bin/bash
#: Title:		: stuff
#: Author		: clewsy (clewsy.pro)
#: Description	: Pulls a bunch of system info, formats and prints to screen.
#: Options		: -A	All info.
#:				: -l	Live data (temps, fan speeds, users, uptime).
#:				: -p	Product info.
#:				: -c 	CPU info.
#:				: -m	Memory info.
#:				: -a	Audio hardware info.
#:				: -v	Video hardware info.
#:				: -d	Disks and partitions info.
#:				: -o	Operating system and kernel info.
#:				: -n	Network info.
#:				: -h	Print help/usage.
#:				: none	Assumes "-A".

## Exit codes.
SUCCESS=0
BAD_OPTION=1
BAD_ARGUMENT=2

## Define theme colour options.
BLACK="\\033[00;30m"
RED="\\033[00;31m"
ORANGE="\\033[00;38;5;214m"
GREEN="\\033[00;32m"
YELLOW="\\033[00;33m"
BLUE="\\033[00;34m"
MAGENTA="\\033[00;35m"
CYAN="\\033[00;36m"
GRAY="\\033[00;40m"
WHITE="\\033[00;37m"

## Set theme colour.
DEFAULT_COL="${CYAN}"

## Text emphasis.
BOLD="\\033[1m"
DIM="\\033[2m"
RESET="\\033[0m"

## Define usage/help.
USAGE="
Usage: $(basename "$0") [option]
Valid options:
-A	All info.
-l	Live data (temps, fan speeds, users, uptime).
-p	Product info.
-c 	CPU info.
-m	Memory info.
-a	Audio hardware info.
-v	Video hardware info.
-d	Disks and partitions info.
-o	Operating system and kernel info.
-n	Network info.
-h	Print this help.
"

## Get command line options and set appropriate flags.
while getopts 'Alpcmavdonh' OPTION; do		## Call getopts to identify selected options and set corresponding flags.
	OPTIONS="TRUE"							## Used to determine if a valid or invalid option was entered.
	case "$OPTION" in
		A)	GET_ALL_INFO="TRUE" ;;			## Set ALL flag - same output as selecting no options.
		l)	GET_L_LIVE_INFO="TRUE" ;;		## Set L flag - live system statistics (temp, fan speed, uptime).
		p)	GET_P_PRODUCT_INFO="TRUE" ;;	## Set P flag - product info (inc. motherboard, chassis, bios).
		c)	GET_C_CPU_INFO="TRUE" ;;		## Set C flag - cpu.
		m)	GET_M_MEMORY_INFO="TRUE" ;;		## Set M flag - memory.
		a)	GET_A_AUDIO_INFO="TRUE" ;;		## Set A flag - audio hardware.
		v)	GET_V_VIDEO_INFO="TRUE" ;;		## Set V flag - video hardware.
		d)	GET_D_DISKS_INFO="TRUE" ;;		## Set D flag - disks and partitions (inc. raid).
		o)	GET_O_OS_INFO="TRUE" ;;			## Set O flag - operating system (inc. kernel).
		n)	GET_N_NETWORK_INFO="TRUE" ;;	## Set N flag - network.
		h)	printf "%b" "${USAGE}\n"		## Print help (usage).
			exit ${SUCCESS} ;;				## Exit successfully.
		?)	printf "%b" "${USAGE}\n"		## Invalid option, show usage.
			exit ${BAD_OPTION} ;;			## Exit.
	esac
done
shift $((OPTIND -1))		## This ensures only non-option arguments are considered arguments when referencing $#, #* and $n.

## If no options selected,assumes -A option so set GET_ALL_INFO flag.
if [ -z "$OPTIONS" ]; then GET_ALL_INFO="TRUE"; fi

## Ensure no more than 1 argument was entered.
if (( $# > 1 )); then
	printf "%b" "${RED}Error:${RESET} Invalid argument.\n"
	printf "%b" "${USAGE}\n"
	exit $BAD_ARGUMENT
fi

## Parse the first argument to set the theme colour.
case $1 in
	"BLACK" 	| "black")		COL="${BLACK}";;
	"RED"		| "red")		COL="${RED}";;
	"ORANGE"	| "orange")		COL="${ORANGE}";;
	"GREEN"		| "green")		COL="${GREEN}";;
	"YELLOW"	| "yellow")		COL="${YELLOW}";;
	"BLUE"		| "blue")		COL="${BLUE}";;
	"MAGENTA"	| "magenta")	COL="${MAGENTA}";;
	"CYAN"		| "cyan")		COL="${CYAN}";;
	"GRAY"		| "gray")		COL="${GRAY}";;
	"WHITE"		| "white")		COL="${WHITE}";;
	*)							COL="${DEFAULT_COL}";;
esac

## Begin main output.  Start with a header.
printf "%b" "\n${COL}${BOLD}╔════════════════════╗${RESET}\n"
printf "%b" "${COL}${BOLD}║${RESET} ${BOLD}System Information ${RESET}${COL}${BOLD}║${RESET}\n"
printf "%b" "${COL}${BOLD}╚════════════════════╝${RESET}\n"

####################################################################################################################################
## -l : Print live statistics - temperature, fan speed, uptime
if [[ ${GET_L_LIVE_INFO} || ${GET_ALL_INFO} ]]; then

	printf "%b" "${COL}${BOLD}Live statistics:${RESET}\n"

	## Initialise some counters.
	FOUND_CORE_TEMP=0
	FOUND_FAN=0

	## If sensors is available, use that to determine core temps and fan speeds.
	if sensors &> /dev/null; then
		###############################
		## Print available CPU core temps - lm_sensors
		for CHECK in {0..11}; do	## Look for up to 12 core temps.
			CORE_TEMP="$(sensors | grep "Core ${CHECK}" | awk '{print $3}')"
			if [ -n "${CORE_TEMP}" ]; then
				(( FOUND_CORE_TEMP++ ))
				CORE_TEMP_[${FOUND_CORE_TEMP}]=${CORE_TEMP}
			fi
		done
		if (( FOUND_CORE_TEMP > 0 )); then
			printf "%b" "${COL}${BOLD}├─Core Temperatures:${RESET}\n"
			for (( CORE=1; CORE<=FOUND_CORE_TEMP; CORE++ )); do	## Loop for each found core.
				if (( CORE == FOUND_CORE_TEMP )); then	printf "%b" "${COL}│ └─Core ${CORE} Temp:${RESET} ${CORE_TEMP_[${CORE}]}\n"
				else									printf "%b" "${COL}│ ├─Core ${CORE} Temp:${RESET} ${CORE_TEMP_[${CORE}]}\n"; fi
			done
		fi
		###############################
		## Print available fan speeds - lm_sensors
		for CHECK in {1..9}; do	## Look for up to 9 fans.
			FAN_SPEED="$(sensors | grep "fan${CHECK}" | awk '{print $2}')"
			if [ -n "${FAN_SPEED}" ] && [ "${FAN_SPEED}" != "0" ]; then
				(( FOUND_FAN++ ))
				FAN_SPEED_[$FOUND_FAN]=${FAN_SPEED}
			fi
		done
		if (( FOUND_FAN > 0 )); then
			printf "%b" "${COL}${BOLD}├─Fan Speeds:${RESET}\n"
			for (( FAN=1; FAN<=FOUND_FAN; FAN++ )); do	## Loop for each found fan.
				if (( FAN == FOUND_FAN )); then	printf "%b" "${COL}│ └─Fan ${FAN} Speed:${RESET} ${FAN_SPEED_[${FAN}]}rpm\n"
				else							printf "%b" "${COL}│ ├─Fan ${FAN} Speed:${RESET} ${FAN_SPEED_[${FAN}]}rpm\n"; fi
			done
		fi
	fi

	###############################
	## Print available core temp - raspberry pi.
	## Sensors is not available or returned no temps, but temp file is present (likely a pi) so use that to show temperature.
	if (( FOUND_CORE_TEMP == 0 )) && [ -f /sys/class/thermal/thermal_zone0/temp ]; then
		RAW_CORE_TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2> /dev/null)	## File contains inte value equal to 1000*temp.
		if (( RAW_CORE_TEMP )); then
			CORE_TEMP="$(( RAW_CORE_TEMP/1000 )).$(( RAW_CORE_TEMP%1000 ))°C"
			printf "%b" "${COL}${BOLD}├─Core Temperature:${RESET} ${CORE_TEMP}\n"
		fi
	fi

	###############################
	## Print uptime and number of logged-in users.
	if command -v who > /dev/null ; then	printf "%b" "${COL}${BOLD}├─Total Users:${RESET} $(who | wc -l)\n"; fi
	printf "%b" "${COL}${BOLD}└─Uptime:${RESET} $(uptime -p)\n"
fi

####################################################################################################################################
## -p : Print available product, chassis, motherboard, bios info
if [[ ${GET_P_PRODUCT_INFO} || ${GET_ALL_INFO} ]]; then

	## Check for a few basics.  If not present, assume no product info is present.
	if	[ ! -s /sys/devices/virtual/dmi/id/product_name ]	&&
		[ ! -s /sys/devices/virtual/dmi/id/chassis_type ]	&&
		[ ! -s /sys/devices/virtual/dmi/id/board_name ]		&&
		[ ! -s /sys/devices/virtual/dmi/id/bios_date ];		then printf "%b" "${COL}${BOLD}Product Info:${RESET} Not found\n"
	else
		printf "%b" "${COL}${BOLD}Product Info:${RESET}\n"
		if [ -s /sys/devices/virtual/dmi/id/product_name ];		then PRODUCT_NAME=$(cat /sys/devices/virtual/dmi/id/product_name); fi
		if [ -s /sys/devices/virtual/dmi/id/product_version ];	then PRODUCT_VERSION=$(cat /sys/devices/virtual/dmi/id/product_version); fi
		if [ -s /sys/devices/virtual/dmi/id/sys_vendor ];		then SYS_VENDOR=$(cat /sys/devices/virtual/dmi/id/sys_vendor); fi
		if [ -s /sys/devices/virtual/dmi/id/chassis_type ];		then CHASSIS_TYPE=$(cat /sys/devices/virtual/dmi/id/chassis_type); fi
		if [ -s /sys/devices/virtual/dmi/id/chassis_version ];	then CHASSIS_VERSION=$(cat /sys/devices/virtual/dmi/id/chassis_version); fi
		if [ -s /sys/devices/virtual/dmi/id/chassis_vendor ];	then CHASSIS_VENDOR=$(cat /sys/devices/virtual/dmi/id/chassis_vendor); fi
		if [ -s /sys/devices/virtual/dmi/id/board_name ];		then BOARD_NAME=$(cat /sys/devices/virtual/dmi/id/board_name); fi
		if [ -s /sys/devices/virtual/dmi/id/board_version ];	then BOARD_VERSION=$(cat /sys/devices/virtual/dmi/id/board_version); fi
		if [ -s /sys/devices/virtual/dmi/id/board_vendor ];		then BOARD_VENDOR=$(cat /sys/devices/virtual/dmi/id/board_vendor); fi
		if [ -s /sys/devices/virtual/dmi/id/bios_date ];		then BIOS_DATE=$(cat /sys/devices/virtual/dmi/id/bios_date); fi
		if [ -s /sys/devices/virtual/dmi/id/bios_version ];		then BIOS_VERSION=$(cat /sys/devices/virtual/dmi/id/bios_version); fi
		if [ -s /sys/devices/virtual/dmi/id/bios_vendor ];		then BIOS_VENDOR=$(cat /sys/devices/virtual/dmi/id/bios_vendor); fi

		###############################
		## Print available product info
		if		[ -n "${PRODUCT_NAME}" ] &&	[ -n "${PRODUCT_VERSION}" ] &&	[ -n "${SYS_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Product:${RESET} ${PRODUCT_NAME}, version ${PRODUCT_VERSION} (${SYS_VENDOR})\n"
		elif	[ -n "${PRODUCT_NAME}" ] &&	[ -n "${PRODUCT_VERSION}" ];							then	printf "%b" "${COL}${BOLD}├─Product:${RESET} ${PRODUCT_NAME}, version ${PRODUCT_VERSION}\n"
		elif 	[ -n "${PRODUCT_NAME}" ] &&									[ -n "${SYS_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Product:${RESET} ${PRODUCT_NAME} (${SYS_VENDOR})\n"
		elif	[ -n "${PRODUCT_NAME}" ];															then	printf "%b" "${COL}${BOLD}├─Product:${RESET} ${PRODUCT_NAME}\n"; fi

		###############################
		## Print available chassis info
		if		[ -n "${CHASSIS_TYPE}" ] &&	[ -n "${CHASSIS_VERSION}" ] &&	[ -n "${CHASSIS_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Chassis:${RESET} ${CHASSIS_TYPE}, version ${CHASSIS_VERSION} (${CHASSIS_VENDOR})\n"
		elif	[ -n "${CHASSIS_TYPE}" ] &&	[ -n "${CHASSIS_VERSION}" ];								then	printf "%b" "${COL}${BOLD}├─Chassis:${RESET} ${CHASSIS_TYPE}, version ${CHASSIS_VERSION}\n"
		elif	[ -n "${CHASSIS_TYPE}" ] &&									[ -n "${CHASSIS_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Chassis:${RESET} ${CHASSIS_TYPE} (${CHASSIS_VENDOR})\n"
		elif	[ -n "${CHASSIS_TYPE}" ];																then	printf "%b" "${COL}${BOLD}├─Chassis:${RESET} ${CHASSIS_TYPE}\n"; fi

		###############################
		## Print available motherboard info
		if		[ -n "${BOARD_NAME}" ] &&	[ -n "${BOARD_VERSION}" ] &&	[ -n "${BOARD_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Motherboard:${RESET} ${BOARD_NAME}, version ${BOARD_VERSION} (${BOARD_VENDOR})\n"
		elif	[ -n "${BOARD_NAME}" ] &&	[ -n "${BOARD_VERSION}" ];									then	printf "%b" "${COL}${BOLD}├─Motherboard:${RESET} ${BOARD_NAME}, version ${BOARD_VERSION}\n"
		elif	[ -n "${BOARD_NAME}" ] &&									[ -n "${BOARD_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Motherboard:${RESET} ${BOARD_NAME} (${BOARD_VENDOR})\n"
		elif	[ -n "${BOARD_NAME}" ];																	then	printf "%b" "${COL}${BOLD}├─Motherboard:${RESET} ${BOARD_NAME}\n"; fi

		###############################
		## Print available bios info
		if		[ -n "${BIOS_DATE}" ] &&	[ -n "${BIOS_VERSION}" ] &&	[ -n "${BIOS_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}└─Bios:${RESET} ${BIOS_DATE}, version ${BIOS_VERSION} (${BIOS_VENDOR})\n"
		elif	[ -n "${BIOS_DATE}" ] &&	[ -n "${BIOS_VERSION}" ];								then	printf "%b" "${COL}${BOLD}└─Bios:${RESET} ${BIOS_DATE}, version ${BIOS_VERSION}\n"
		elif	[ -n "${BIOS_DATE}" ] &&								[ -n "${BIOS_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}└─Bios:${RESET} ${BIOS_DATE} (${BIOS_VENDOR})\n"
		elif	[ -n "${BIOS_DATE}" ];																then	printf "%b" "${COL}${BOLD}└─Bios:${RESET} ${BIOS_DATE}\n"; fi
	fi
fi

####################################################################################################################################
##  -c : Print available CPU info
if [[ ${GET_C_CPU_INFO} || ${GET_ALL_INFO} ]]; then
	if ! command -v lscpu >> /dev/null ; then	## If lscpu not installed (send to /dev/null to suppress stdout)
		printf "%b" "${COL}${BOLD}CPU:${RESET} Cannot determine cpu infomtion (lscpu not installed)\n"
	else
		CPU_MODEL=$(lscpu | grep -m 1 -e "Model name:" | sed 's/Model name: *//')
		CPU_VENDOR=$(lscpu | grep -m 1 -e "Vendor ID:" | sed 's/Vendor ID: *//')
		CPU_ARCH=$(lscpu | grep -m 1 -e "Architecture:" | sed 's/Architecture: *//')
		CPU_MODE=$(lscpu | grep -m 1 -e "CPU op-mode(s):" | sed 's/CPU op-mode(s): *//')
		CPU_CORES=$(lscpu | grep -m 1 -e "CPU(s):" | sed 's/CPU(s): *//')
		CPU_SPEED=$(lscpu | grep -m 1 -e "CPU MHz:" | sed 's/CPU MHz: *//')
		CPU_MAX_SPEED=$(lscpu | grep -m 1 -e "CPU max MHz:" | sed 's/CPU max MHz: *//')
		CPU_MIN_SPEED=$(lscpu | grep -m 1 -e "CPU min MHz:" | sed 's/CPU min MHz: *//')
		printf "%b" "${COL}${BOLD}CPU:${RESET}\n"
		if [ -n "${CPU_MODEL}" ];	then	printf "%b" "${COL}${BOLD}├─Model:${RESET} ${CPU_MODEL}\n"; fi			## CPU Model
		if [ -n "${CPU_VENDOR}" ];	then	printf "%b" "${COL}${BOLD}├─Vendor:${RESET} ${CPU_VENDOR}\n"; fi		## CPUM Vendor
		if [ -n "${CPU_ARCH}" ];	then	printf "%b" "${COL}${BOLD}├─Architecture:${RESET} ${CPU_ARCH}\n"; fi	## Architecture
		if [ -n "${CPU_MODE}" ];	then	printf "%b" "${COL}${BOLD}├─Mode(s):${RESET} ${CPU_MODE}\n"; fi			## CPU Mode
		if [ -n "${CPU_CORES}" ];	then	printf "%b" "${COL}${BOLD}├─Cores:${RESET} ${CPU_CORES}\n"; fi			## CPU(s)
		if [ -n "${CPU_SPEED}" ];	then	printf "%b" "${COL}${BOLD}└─Speed:${RESET} ${CPU_SPEED}MHz\n"			## CPU Speed
		else								printf "%b" "${COL}${BOLD}└─Speed\n"; fi
		if [ -n "${CPU_MAX_SPEED}" ] && [ -n "${CPU_MIN_SPEED}" ]; then
			printf "%b" "${COL}  ├─Max:${RESET} ${CPU_MAX_SPEED}MHz\n"; 	## Max CPU MHz
			printf "%b" "${COL}  └─Min:${RESET} ${CPU_MIN_SPEED}MHz\n";		## Min CPU MHz
		else
			if [ -n "${CPU_MAX_SPEED}" ]; then printf "%b" "${COL}  └─Max:${RESET} ${CPU_MAX_SPEED}MHz\n"; fi	## Max CPU MHz
			if [ -n "${CPU_MIN_SPEED}" ]; then printf "%b" "${COL}  └─Min:${RESET} ${CPU_MIN_SPEED}MHz\n"; fi	## Min CPU MHz
		fi
	fi
fi

####################################################################################################################################
## -m : Print memory info
if [[ ${GET_M_MEMORY_INFO} || ${GET_ALL_INFO} ]]; then
	printf "%b" "${COL}${BOLD}Memory:${RESET}\n"
	printf "%b" "${COL}${BOLD}├─RAM:${RESET}\n"
	printf "%b" "${COL}${BOLD}│ ${RESET}${COL}├─Total:    ${RESET} $(free -h | grep "Mem:" | awk '{print $2}')\n"
	printf "%b" "${COL}${BOLD}│ ${RESET}${COL}├─Used:     ${RESET} $(free -h | grep "Mem:" | awk '{print $3}')\n"
	printf "%b" "${COL}${BOLD}│ ${RESET}${COL}└─Available:${RESET} $(free -h | grep "Mem:" | awk '{print $7}')\n"
	printf "%b" "${COL}${BOLD}└─SWAP:${RESET}\n"
	printf "%b" "${COL}  ├─Total:    ${RESET} $(free -h | grep "Swap" | awk '{print $2}')\n"
	printf "%b" "${COL}  ├─Used:     ${RESET} $(free -h | grep "Swap" | awk '{print $3}')\n"
	printf "%b" "${COL}  └─Free:     ${RESET} $(free -h | grep "Swap" | awk '{print $4}')\n"
fi

####################################################################################################################################
## -a & -v : Print audio and video info (note only first result of each if multiple video or audio devices exist)
if [[ ${GET_A_AUDIO_INFO} || ${GET_V_VIDEO_INFO} || ${GET_ALL_INFO} ]]; then
	if ! command -v lspci >> /dev/null || ! lspci &> /dev/null; then
		printf "%b" "${COL}${BOLD}Audio/Video:${RESET} Cannot determine audio or video information (lspci not installed)\n"
	else
		## Both audio and video:
		if [[ ${GET_ALL_INFO} || ${GET_A_AUDIO_INFO} && ${GET_V_VIDEO_INFO} ]]; then
			AUDIO_INFO=$(lspci -k | grep -m 1 "Audio" | cut -c23-)
			VIDEO_INFO=$(lspci -k | grep -m 1 "VGA" | cut -c36-)
			if		xdpyinfo &> /dev/null;	then VIDEO_RES=$(xdpyinfo | grep "dimensions" | awk '{print $2}')
			elif	xrandr &> /dev/null;	then VIDEO_RES=$(xrandr | grep "current" | cut -d ',' -f 2 | awk '{print $2$3$4}'); fi
			if [ -z "${AUDIO_INFO}" ]; then AUDIO_INFO="Information not found"; fi
			if [ -z "${VIDEO_INFO}" ]; then VIDEO_INFO="Information not found"; fi
			printf "%b" "${COL}${BOLD}Audio/Video:${RESET}\n"
			printf "%b" "${COL}${BOLD}├─Audio Hardware:${RESET} ${AUDIO_INFO}\n"
			printf "%b" "${COL}${BOLD}└─Video Hardware:${RESET} ${VIDEO_INFO}\n"
			if [ -n "${VIDEO_RES}" ]; then printf "%b" "${COL}  └─Resolution:${RESET} ${VIDEO_RES}\n"; fi
		## Just audio:
		elif [ -n "$GET_A_AUDIO_INFO" ]; then
			AUDIO_INFO=$(lspci -k | grep -m 1 "Audio" | cut -c23-)
			if [ -z "${AUDIO_INFO}" ]; then AUDIO_INFO="Information not found"; fi
			printf "%b" "${COL}${BOLD}Audio:${RESET}\n"
			printf "%b" "${COL}${BOLD}└─Hardware:${RESET} ${AUDIO_INFO}\n"
		## Just video:
		elif [ -n "$GET_V_VIDEO_INFO" ]; then
			VIDEO_INFO=$(lspci -k | grep -m 1 "VGA" | cut -c36-)
			if xrandr &> /dev/null; then VIDEO_RES=$(xrandr | grep "current" | cut -d ',' -f 2 | awk '{print $2$3$4}'); fi
			if [ -z "${VIDEO_INFO}" ]; then VIDEO_INFO="Information not found"; fi
			printf "%b" "${COL}${BOLD}Video:${RESET}\n"
			printf "%b" "${COL}${BOLD}└─Hardware:${RESET} ${VIDEO_INFO}\n"
			if [ -n "${VIDEO_RES}" ]; then printf "%b" "${COL}  └─Resolution:${RESET} ${VIDEO_RES}\n"; fi
		fi
	fi
fi

####################################################################################################################################
## -d : Print disk and partition info
if [[ ${GET_D_DISKS_INFO} || ${GET_ALL_INFO} ]]; then
	if ! command -v lsblk >> /dev/null || ! lsblk &> /dev/null;	then
		printf "%b" "${COL}${BOLD}Disks:${RESET} Cannot determine disk/partition information (lsblk absent or failed).\n"
	else
		printf "%b" "${COL}${BOLD}Disks and Partitions:${RESET}\n"

		## Dump lsblk device listing and map each line to an array element.
		mapfile DEV_DUMP <<< "$(lsblk -J)"

		## Identify then delete elements from the array that we want to ignore.
		for (( N = 0; N < ${#DEV_DUMP[@]}; N++ )); do
			if grep -e "loop" <<< "${DEV_DUMP[((N))]}" >> /dev/null; then	DELETE_ELEMENTS+=("${N}") && continue; fi
			if ! grep -e "name" <<< "${DEV_DUMP[((N))]}" >> /dev/null; then	DELETE_ELEMENTS+=("${N}") && continue; fi
			DEV_DUMP[$N]=${DEV_DUMP[$N]//", "/","}	## Eliminate all but the initial whitespace.  LEVEL determined by #whitespace.
		done
		for ELEMENT in ${DELETE_ELEMENTS[@]}; do unset DEV_DUMP[${ELEMENT}]; done

		## Reconstitute the array - removes all empty elements.
		DEV_DUMP=("${DEV_DUMP[@]}")

		## Run through each element in the DEV_DUMP array and create a new array of the format:
		## ( DEV_NAME DEV_LEVEL DEV_CHILDREN )
		## Where 	: DEV_NAME is the name of the device within the /dev directory.
		##			: DEV_LEVEL represents the position within the device heirarchy.  E.g. Level 1 for sda, level 2 for sda1.
		##			: NUM_CHILDREN	represents the child devices one level below the device.  Does not count great/grandchildren.
		## Also tally the total number of level 1 devices NUM_LEVEL_1.
		NUM_LEVEL_1=0
		for (( E = 0; E < ${#DEV_DUMP[@]}; E++ )); do
			DEV_NAME=$(cut -d "\"" -f 4 <<< "${DEV_DUMP[$E]}")
			LEVEL=$(( $(tr -cd ' ' <<< "${DEV_DUMP[$E]}" | wc -m) / 6 )) ## Determine level by counting initial whitespace.
			NEXT_LEVEL=$(( $(tr -cd ' ' <<< "${DEV_DUMP[((E+1))]}" | wc -m) / 6 ))
			DIFF=$((NEXT_LEVEL-LEVEL))
			NUM_CHILDREN=0

			## Loop through the next elements until we reach one of the same level - allows us to count the children.
			i=1
			while (( NEXT_LEVEL > LEVEL )); do
				## If level difference is 1, current element is a direct child.  Ignores grandchildren & great-grandchildren.
				if ((DIFF == 1)); then ((NUM_CHILDREN++)); fi

				## Increment the counter and check the next element.
				((i++))
				NEXT_LEVEL=$(( $(tr -cd ' ' <<< "${DEV_DUMP[((E+i))]}" | wc -m) / 6 )) ## Determine level by initial whitespace.
				DIFF=$((NEXT_LEVEL-LEVEL))
			done

			## Add the element to the array.
			DEV_ARRAY+=("${DEV_NAME} ${LEVEL} ${NUM_CHILDREN}")

			## Increment the level 1 tally.
			if ((LEVEL == 1)); then ((NUM_LEVEL_1++)); fi

		done

		## Loop through the DEV_ARRAY, format and print device information.
		for (( D=0; D<${#DEV_ARRAY[@]}; D++ )); do

			WORKING_ELEMENT="${DEV_ARRAY[$D]}"
			WORKING_DEV_NAME=$(awk '{print $1}' <<< "${WORKING_ELEMENT}")
			WORKING_LEVEL=$(awk '{print $2}' <<< "${WORKING_ELEMENT}")
			WORKING_NUM_CHILDREN=$(awk '{print $3}' <<< "${WORKING_ELEMENT}")

			################################
			## Level 1 devices
			if ((WORKING_LEVEL == 1)); then
				((LEVEL_1_TALLY++))
				if (( LEVEL_1_TALLY == NUM_LEVEL_1 )); then	## Last device in the list.
					printf "%b" "${COL}${BOLD}└─Device:${RESET} ${WORKING_DEV_NAME}\n"
					C1="${COL}${BOLD}  ${RESET}"
				else
					printf "%b" "${COL}${BOLD}├─Device:${RESET} ${WORKING_DEV_NAME}\n"
					C1="${COL}${BOLD}│ ${RESET}"
				fi

				DEVICE_TYPE=$(lsblk -dno TYPE /dev/"${WORKING_DEV_NAME}")	## Define device type
				DEVICE_MODEL=$(lsblk -dno MODEL /dev/"${WORKING_DEV_NAME}")	## Define device model
				DEVICE_SIZE=$(lsblk -dno SIZE /dev/"${WORKING_DEV_NAME}")	## Define device capacity
				DEV_SPECS=()	## Clear then reset the array of device specs 
				if [ -n "${DEVICE_TYPE}" ];		then DEV_SPECS+=("${COL}Type:${RESET} ${DEVICE_TYPE}"); fi
				if [ -n "${DEVICE_MODEL}" ];	then DEV_SPECS+=("${COL}Model:${RESET} ${DEVICE_MODEL}"); fi
				if [ -n "${DEVICE_SIZE}" ];		then DEV_SPECS+=("${COL}Size:${RESET} ${DEVICE_SIZE}"); fi
				NUM_DSPECS=${#DEV_SPECS[@]}
				for DSPEC in "${DEV_SPECS[@]}"; do
					if [[ "${DSPEC}" == "${DEV_SPECS[((NUM_DSPECS-1))]}" && ${WORKING_NUM_CHILDREN} -lt 1 ]]; then	C2="${COL}└─${RESET}"
					else																							C2="${COL}├─${RESET}"; fi
					printf "%b" "${C1}${C2}${DSPEC}\n"
				done

				################################
				## Level 2 devices
				if ((WORKING_NUM_CHILDREN > 0)); then
					for ((C=0; C<WORKING_NUM_CHILDREN; C++)); do
						WORKING_CHILD_ELEMENT="${DEV_ARRAY[D+1+C]}"
						WORKING_CHILD_DEV_NAME=$(awk '{print $1}' <<< "${WORKING_CHILD_ELEMENT}")
						WORKING_CHILD_NUM_CHILDREN=$(awk '{print $3}' <<< "${WORKING_CHILD_ELEMENT}")
						if ((C == WORKING_NUM_CHILDREN-1)); then
							printf "%b" "${C1}${COL}└─Child:${RESET} ${WORKING_CHILD_DEV_NAME}\n"
							C2="${COL}  ${RESET}"
						else
							printf "%b" "${C1}${COL}├─Child:${RESET} ${WORKING_CHILD_DEV_NAME}\n"
							C2="${COL}│ ${RESET}"
						fi

						CHILD_LABEL=$(lsblk -dno LABEL /dev/"${WORKING_CHILD_DEV_NAME}")
						CHILD_TYPE=$(lsblk -dno TYPE /dev/"${WORKING_CHILD_DEV_NAME}")
						CHILD_FS=$(df -Th 2>/dev/null | grep -m 1 "${WORKING_CHILD_DEV_NAME}" | awk '{print $2}')
						CHILD_UUID=$(lsblk -dno UUID /dev/"${WORKING_CHILD_DEV_NAME}")
						CHILD_SIZE=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_CHILD_DEV_NAME}" | awk '{print $2}')
						CHILD_USED=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_CHILD_DEV_NAME}" | awk '{print $3}')
						CHILD_PERC=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_CHILD_DEV_NAME}" | awk '{print $5}')
						CHILD_MOUNT=$(lsblk -dno MOUNTPOINT /dev/"${WORKING_CHILD_DEV_NAME}") 

						CHILD_SPECS=()	## Clear then reset the array of child specs
						if [ -n "${CHILD_LABEL}" ];	then CHILD_SPECS+=("${COL}${DIM}Label:${RESET} ${CHILD_LABEL}"); fi
						if [ -n "${CHILD_TYPE}" ];	then CHILD_SPECS+=("${COL}${DIM}Type:${RESET} ${CHILD_TYPE}"); fi
						if [ -n "${CHILD_FS}" ];	then CHILD_SPECS+=("${COL}${DIM}Filesystem:${RESET} ${CHILD_FS}"); fi
						if [ -n "${CHILD_UUID}" ];	then CHILD_SPECS+=("${COL}${DIM}UUID:${RESET} ${CHILD_UUID}"); fi
						if [ -n "${CHILD_SIZE}" ];	then CHILD_SPECS+=("${COL}${DIM}Size:${RESET} ${CHILD_SIZE}"); fi
						if [ -n "${CHILD_USED}" ];	then CHILD_SPECS+=("${COL}${DIM}Usage:${RESET} ${CHILD_USED} (${CHILD_PERC})"); fi
						if [ -n "${CHILD_MOUNT}" ];	then CHILD_SPECS+=("${COL}${DIM}Mount:${RESET} ${CHILD_MOUNT}"); fi
						NUM_CSPECS=${#CHILD_SPECS[@]}

						for CSPEC in "${CHILD_SPECS[@]}"; do
							if [[ "${CSPEC}" == "${CHILD_SPECS[((NUM_CSPECS-1))]}" && ${WORKING_CHILD_NUM_CHILDREN} -lt 1 ]]; then	C3="${COL}${DIM}└─${RESET}"
							else																									C3="${COL}${DIM}├─${RESET}"; fi
							printf "%b" "${C1}${C2}${C3}${CSPEC}\n"
						done

						################################
						## Level 3 devices
						if ((WORKING_CHILD_NUM_CHILDREN > 0)); then
							for ((GC=0; GC<WORKING_CHILD_NUM_CHILDREN; GC++)); do
								WORKING_GRANDCHILD_ELEMENT="${DEV_ARRAY[D+1+C+1+GC]}"
								WORKING_GRANDCHILD_DEV_NAME=$(awk '{print $1}' <<< "${WORKING_GRANDCHILD_ELEMENT}")
								WORKING_GRANDCHILD_NUM_CHILDREN=$(awk '{print $3}' <<< "${WORKING_GRANDCHILD_ELEMENT}")
								if ((GC == WORKING_CHILD_NUM_CHILDREN-1)); then
									printf "%b" "${C1}${C2}${COL}${DIM}└─Grandchild:${RESET} ${WORKING_GRANDCHILD_DEV_NAME}\n"
									C3="${COL}${DIM}  ${RESET}"
								else
									printf "%b" "${C1}${C2}${COL}${DIM}├─Grandchild:${RESET} ${WORKING_GRANDCHILD_DEV_NAME}\n"
									C3="${COL}${DIM}│ ${RESET}"
								fi

								if [ -e /dev/"${WORKING_GRANDCHILD_DEV_NAME}" ]; then GRANDCHILD_LABEL=$(lsblk -dno LABEL /dev/"${WORKING_GRANDCHILD_DEV_NAME}"); fi
								GRANDCHILD_TYPE=$(lsblk -in /dev/"${WORKING_CHILD_DEV_NAME}" | grep "${WORKING_GRANDCHILD_DEV_NAME}" | awk '{print $6}')
								GRANDCHILD_FS=$(df -Th 2>/dev/null | grep -m 1 "${WORKING_GRANDCHILD_DEV_NAME}" | awk '{print $2}')
								GRANDCHILD_SIZE=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_GRANDCHILD_DEV_NAME}" | awk '{print $2}')
								GRANDCHILD_USED=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_GRANDCHILD_DEV_NAME}" | awk '{print $3}')
								GRANDCHILD_PERC=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_GRANDCHILD_DEV_NAME}" | awk '{print $5}' )
								GRANDCHILD_MOUNT=$(lsblk -in /dev/"${WORKING_CHILD_DEV_NAME}" | grep "${WORKING_GRANDCHILD_DEV_NAME}" | awk '{print $7}')

								GRANDCHILD_SPECS=()	## Clear then reset the array of child specs
								if [ -n "${GRANDCHILD_TYPE}" ];		then GRANDCHILD_SPECS+=("${COL}${DIM}Type:${RESET} ${GRANDCHILD_TYPE}"); fi
								if [ -n "${GRANDCHILD_FS}" ];		then GRANDCHILD_SPECS+=("${COL}${DIM}Filesystem:${RESET} ${GRANDCHILD_FS}"); fi
								if [ -n "${GRANDCHILD_SIZE}" ];		then GRANDCHILD_SPECS+=("${COL}${DIM}Size:${RESET} ${GRANDCHILD_SIZE}"); fi
								if [ -n "${GRANDCHILD_USED}" ];		then GRANDCHILD_SPECS+=("${COL}${DIM}Usage:${RESET} ${GRANDCHILD_USED} (${GRANDCHILD_PERC})"); fi
								if [ -n "${GRANDCHILD_MOUNT}" ];	then GRANDCHILD_SPECS+=("${COL}${DIM}Mount:${RESET} ${GRANDCHILD_MOUNT}"); fi
								NUM_GCSPECS=${#GRANDCHILD_SPECS[@]}
								for GCSPEC in "${GRANDCHILD_SPECS[@]}" ; do	## Loop for each grandchild spec
									if [[ "${GCSPEC}" == "${GRANDCHILD_SPECS[((NUM_GSPECS-1))]}" && ${WORKING_GRANDCHILD_NUM_CHILDREN} -lt 1 ]]; then	C4="${COL}${DIM}└─${RESET}"
									else																												C4="${COL}${DIM}├─${RESET}"; fi
									printf "%b" "${C1}${C2}${C3}${C4}${GCSPEC}\n"
								done

								################################
								## Level 4 devices
								if ((WORKING_GRANDCHILD_NUM_CHILDREN > 0)); then
									for ((GGC=0; GGC<WORKING_GRANDCHILD_NUM_CHILDREN; GGC++)); do
										WORKING_GREATGRANDCHILD_ELEMENT="${DEV_ARRAY[D+1+C+1+GC+1+GGC]}"
										WORKING_GREATGRANDCHILD_DEV_NAME=$(awk '{print $1}' <<< "${WORKING_GREATGRANDCHILD_ELEMENT}")
										WORKING_GREATGRANDCHILD_NUM_CHILDREN=$(awk '{print $3}' <<< "${WORKING_GREATGRANDCHILD_ELEMENT}")
										if ((GGC == WORKING_GRANDCHILD_NUM_CHILDREN-1)); then
											printf "%b" "${C1}${C2}${C3}${COL}${DIM}└─Great-Grandchild:${RESET} ${WORKING_GREATGRANDCHILD_DEV_NAME}\n"
											C4="${COL}${DIM}  ${RESET}"
										else
											printf "%b" "${C1}${C2}${C3}${COL}${DIM}├─Great-Grandchild:${RESET} ${WORKING_GREATGRANDCHILD_DEV_NAME}\n"
											C4="${COL}${DIM}│ ${RESET}"
										fi

										GREATGRANDCHILD_FS=$(df -Th 2>/dev/null | grep -m 1 "${WORKING_GREATGRANDCHILD_DEV_NAME}" | awk '{print $2}')
										GREATGRANDCHILD_SIZE=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_GREATGRANDCHILD_DEV_NAME}" | awk '{print $2}')
										GREATGRANDCHILD_USED=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_GREATGRANDCHILD_DEV_NAME}" | awk '{print $3}')
										GREATGRANDCHILD_PERC=$(df -lh 2>/dev/null | grep -m 1 "${WORKING_GREATGRANDCHILD_DEV_NAME}" | awk '{print $5}' )

										GREATGRANDCHILD_SPECS=()	## Clear then reset the array of child specs
										if [ -n "${GREATGRANDCHILD_FS}" ];		then GREATGRANDCHILD_SPECS+=("${COL}${DIM}Filesystem:${RESET} ${GREATGRANDCHILD_FS}"); fi
										if [ -n "${GREATGRANDCHILD_USED}" ];	then GREATGRANDCHILD_SPECS+=("${COL}${DIM}Size:${RESET} ${GREATGRANDCHILD_SIZE}"); fi
										if [ -n "${GREATGRANDCHILD_USED}" ];	then GREATGRANDCHILD_SPECS+=("${COL}${DIM}Usage:${RESET} ${GREATGRANDCHILD_USED} (${GREATGRANDCHILD_PERC})"); fi
										NUM_GGCSPECS=${#GREATGRANDCHILD_SPECS[@]}
										for GGCSPEC in "${GREATGRANDCHILD_SPECS[@]}" ; do	## Loop for each grandchild spec
											if [[ "${GGCSPEC}" == "${GREATGRANDCHILD_SPECS[((NUM_GGSPECS-1))]}" && ${WORKING_GREATGRANDCHILD_NUM_CHILDREN} -lt 1 ]]; then	C5="${COL}${DIM}└─${RESET}"
											else																															C5="${COL}${DIM}├─${RESET}"; fi
											printf "%b" "${C1}${C2}${C3}${C4}${C5}${GGCSPEC}\n"
										done
									done
								fi
							done
						fi
					done
				fi
			fi
		done
	fi
fi

####################################################################################################################################
## -o : Print OS kernel and distribution info
if [[ ${GET_O_OS_INFO} || ${GET_ALL_INFO} ]]; then
	OS_NAME=$(uname -o)
	ARCH=$(uname -m)
	KERNEL=$(uname -s)
	KERNEL_VER=$(uname -v)
	KERNEL_REL=$(uname -r)
	if command -v lsb_release >> /dev/null; then	DIST=$(lsb_release -i | cut -f2)
													DIST_REL=$(lsb_release -r | cut -f2)
													DIST_CODE=$(lsb_release -c | cut -f2);
	fi
	SHELL_IN_USE=$(basename "${SHELL}")

	printf "%b" "${COL}${BOLD}Operating System:${RESET}\n"
	printf "%b" "${COL}${BOLD}├─OS:${RESET} ${OS_NAME}\n"
	printf "%b" "${COL}${BOLD}├─Architecture:${RESET} ${ARCH}\n"
	printf "%b" "${COL}${BOLD}├─Kernel:${RESET} ${KERNEL}\n"
	printf "%b" "${COL}${BOLD}│ ${RESET}${COL}├─Version:${RESET} ${KERNEL_VER}\n"
	printf "%b" "${COL}${BOLD}│ ${RESET}${COL}└─Release:${RESET} ${KERNEL_REL}\n"
	if [ -z "${DIST}" ]; then	printf "%b" "${COL}${BOLD}├─Distribution: ${RESET}Unknown (no lsb_release)\n"
	else						printf "%b" "${COL}${BOLD}├─Distribution:${RESET} ${DIST}\n"
								printf "%b" "${COL}${BOLD}│ ${RESET}${COL}├─Release:${RESET} ${DIST_REL}\n"
								printf "%b" "${COL}${BOLD}│ ${RESET}${COL}└─Codename:${RESET} ${DIST_CODE}\n"
	fi 
	printf "%b" "${COL}${BOLD}└─Shell:${RESET} ${SHELL_IN_USE}\n"
	if [ -n "${BASH_VERSION}" ]; then printf "%b" "${COL}${BOLD}  ${RESET}${COL}└─Version:${RESET} ${BASH_VERSION}\n"; fi
fi

###############################################################################################################################################################
## -n : Print network and network interface info
if [[ ${GET_N_NETWORK_INFO} || ${GET_ALL_INFO} ]]; then
	printf "%b" "${COL}${BOLD}Network:${RESET}\n"

	## Show external IP
	if ! command -v curl >> /dev/null ; then
		EXT_IP="Cannot determine - curl not installed."
	else
		EXT_IP=$(curl --silent --max-time 5 https://ipecho.net/plain)
		if [ -z "${EXT_IP}" ]; then EXT_IP="No External Connection"; fi
		printf "%b" "${COL}${BOLD}├─External IP:${RESET} ${EXT_IP}\n"
	fi

	## Show primary dns address
	if command -v nmcli > /dev/null; then			DNS=$(nmcli dev show | grep -m 1 "DNS" | tr -s " " | cut -d " " -f 2)
	elif  resolvectl &> /dev/null; then				DNS=$(resolvectl status | grep -e "DNS Servers:" | awk '{print $3}')
	elif [ -f /etc/resolv.conf ]; then				DNS=$(grep -m 1 "nameserver" /etc/resolv.conf | cut -d " " -f 2)
	else											DNS="Not found (no nmcli and no /etc/resolve.conf)."; fi
	if [ -n "${DNS}" ]; then printf "%b" "${COL}${BOLD}├─DNS:${RESET} ${DNS}\n"; fi

	## Show default gateway address
	if command -v ip > /dev/null ; then			GW=$(ip route | grep -m 1 "default" | cut -d " " -f 3)
	elif command -v route > /dev/null ; then	GW=$(route -n | grep -m 1 "0.0.0.0" | awk '{print $2}')
	elif command -v netstat > /dev/null ; then	GW=$(netstat -r -n | grep -m 1 "0.0.0.0" | awk '{print $2}')
	else										GW="Cannot determine default gateway address (ip nor route nor netstat installed)"; fi
	if [ "${GW}" = "" ]; then GW="Could not detect gateway."; fi
	printf "%b" "${COL}${BOLD}├─Gateway:${RESET} ${GW}\n"

	## Get hostname
	printf "%b" "${COL}${BOLD}├─Hostname:${RESET} $(uname -n)\n"

	## Get info for all network interface devices (physical and virtual)
	if ! find /sys/class/net &> /dev/null ; then printf "%b" "${COL}${BOLD}└─Interface:${RESET} Cannot detect interfaces (no /sys/class/net/).\n"
	else

		## Run this loop for each interface.
		NUM_DEVS=$(find /sys/class/net -type l | wc -w)
		for (( c=1; c<=NUM_DEVS; c++ ))
		do
			## Define current interface in list.
			WORKING_INTERFACE=$(find /sys/class/net -type l | sed "${c}q;d" | cut -d "/" -f 5)
			if (( c == NUM_DEVS )); then	printf "%b" "${COL}${BOLD}└─Interface:${RESET} ${WORKING_INTERFACE}\n" && C1="${COL}${BOLD}  ${RESET}"
			else							printf "%b" "${COL}${BOLD}├─Interface:${RESET} ${WORKING_INTERFACE}\n" && C1="${COL}${BOLD}│ ${RESET}"; fi

			## Determine current status of interface.
			if [ -e /sys/class/net/"${WORKING_INTERFACE}"/operstate ]; then	STATUS=$(cat /sys/class/net/"${WORKING_INTERFACE}"/operstate)
			else															STATUS="unknown"; fi

			## Determine the MAC address of interface.
			MAC=$(cat /sys/class/net/"${WORKING_INTERFACE}"/address)

			## Determine the IP address assigned o the interface
			if [ "${STATUS}" != "down" ]; then
				if command -v ip > /dev/null; then				IP=$(ip addr show "${WORKING_INTERFACE}" | grep -w -m1 "inet" | cut -d " " -f 6)
				elif command -v ifconfig >> /dev/null ; then	IP=$(ifconfig "${WORKING_INTERFACE}" | grep "inet addr" | cut -d ":" -f 2 | cut -d " " -f 1)
				else											IP="Cannot determine interface ip address (neither ip nor ifconfig installed)"; fi
			fi

			## Determine the connected ESSID (if present)
			if command -v iwgetid >> /dev/null ; then
				IF_WIFI_CONN=$(iwgetid | awk '{print $1}')
				if [ "${IF_WIFI_CONN}" == "${WORKING_INTERFACE}" ]; then	ESSID=$(iwgetid -r)
				else														ESSID=""; fi
			elif command -v iw > /dev/null; then	ESSID=$(iw dev "${WORKING_INTERFACE}" link | grep "SSID" | cut -d " " -f 2)
			elif command -v nmcli > /dev/null; then	ESSID=$(nmcli | grep "${WORKING_INTERFACE}: connected to" | cut -d " " -f 4)
			else									ESSID=""; fi

			if [ "${ESSID}" == "Wired" ] ; then ESSID=""; fi		## If an essid was found

			## Clear and then set the array of interface specs
			INT_SPECS=()
			if [ -n "${STATUS}" ]; then	INT_SPECS+=("${COL}Status:${RESET} ${STATUS}"); fi
			if [ -n "${MAC}" ]; then 	INT_SPECS+=("${COL}Mac Address:${RESET} ${MAC}"); fi
			if [ -n "${IP}" ]; then		INT_SPECS+=("${COL}IP Address:${RESET} ${IP}"); fi
			if [ -n "${ESSID}" ]; then	INT_SPECS+=("${COL}Connected ESSID:${RESET} ${ESSID}"); fi

			## Print out each of the identified specifications for the current inteface
			for (( icspec=0; icspec<${#INT_SPECS[@]}; icspec++ ))
			do
				if (( icspec==(${#INT_SPECS[@]}-1) )); then	C2="${COL}└─${RESET}"
				else										C2="${COL}├─${RESET}"; fi
				printf "%b" "${C1}${C2}${INT_SPECS[icspec]}\n"
			done
		done
	fi
fi

printf "%b" "${COL}${BOLD}──────────────────────────────────────────────────${RESET}\n\n"

exit ${SUCCESS}
